# IMPLEMENTAÇÃO
Nesta etapa do projeto colocaremos em prática o que foi abordado e definido pelas etapas anteriores. De forma a atingir os objetivos estipulados, podemos definir duas diferentes frentes de trabalho. Programação e Montagem do equipamento.

## Programação

O primeiro passo foi realizar testes com os componentes individualmente de forma a verificar e compreender seu funcionamento. Ao longo deste processo pode-se notar que muito do que era feito ali poderia e foi integrado ao código final. Para tal, foi instalado o ESP-IDF, o qual foi utilizado junto ao VS-CODE para implementar todas as funcionalidades desejadas. Este ambiente de desenvolvimento suporta as linguagens C e C++, além de já possuir alguns exemplos que nos guiaram. Apesar destes exemplos, é importante destacar a grande dificuldade de encontrar biografia suficiente para o entendimento pleno da utilização deste framework.

Cada componente foi testado separadamente através de rotinas simples, após isso métodos de interação entre eles foram gerados, resultando em um código funcional que atende as exigências do projeto. Inicialmente, optamos por realizar a comunicação via bluetooth, visto que a partir deste ponto poderíamos prosseguir com a implementação de todo o restante das nossas funcionalidades de forma mais fluída. Para os futuros projetos que desejem seguir com esta implementação, é importante mencionar que foi justamente aqui que encontramos a nossa maior dificuldade durante todo o processo: tornar o código exemplo do Bluetooth em modo de economia de energia funcional às nossas necessidades. Após muito estudo, conseguimos FALAR AQUI COMO SOLUCIONAMOS ESSA BAGAÇA. Após a comunicação ser implementada conforme desejávamos, iniciamos a criação do Aplicativo para Smartphone, a qual seria a nossa interface de controle do usuário. FALAR AQUI DA IMPLEMENTAÇÃO DO APLICATIVO MIT. Para o caso dos motores do carrinho, foi importante entender a documentação disposta no GitHub do LPAE, encontrada [clicando neste link](https://github.com/xtarke/automated_buggy). Implementamos os 4 PWMs necessários para o correto funcinonamento dos motores de acordo com as nossas necessidades. Ao receber os comandos via comunicação bluetooth, o acionamento ocorria de forma satisfatória. Lembrando que o acionamento do carrinho era desejado APENAS por meio da interface do usuário. Por fim, implementamos o servo motor e o sensor de obstáculo. Para o servo motor, implementamos uma rotação de 90º para ambos os lados, fazendo com que este gire o que chamamos de "tremelique". Neste protótipo, implementamos apenas uma volta de 90º no sentido horário e outro no sentido anti-horário, de forma a ser uma validação de conceito. O sensor de obstáculo foi implementado enviando um sinal ao ESP32, o qual ativa o servo motor sempre que o sensor detecta um obstáculo próximo. Portanto, conforme desejado inicialmente, o acionamento do tremelique ocorre por 2 métodos: Controle do usuário por meio do aplicativo, ou aproximação do felino sendo detectada pelo sensor de obstáculo.

Após todos os testes separados, pudemos realizar o código final com todas as aplicações requeridas por este projeto.


